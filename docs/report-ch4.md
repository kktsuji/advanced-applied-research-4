## 4. 提案手法

前章で明らかにしたように、既存のノイズリダクション手法をハードウェアに実装する際には、メモリ容量、計算リソース、処理速度などの深刻な制約が存在する。本章では、これらの制約を克服しつつ効果的なノイズリダクションを実現する新たな手法を提案する。提案手法は、**多重解像度アプローチ**と**小サイズフィルタの組み合わせ**を基本とし、ハードウェア実装に適した設計となっている。

### 4.1 基本コンセプト

#### 多重解像度アプローチの着想

従来のノイズリダクション手法における主要な課題は、大きなフィルタカーネルが必要となることであった。大きなフィルタは効果的なノイズ除去を実現できるが、3.1節で述べたように、ラインバッファのメモリ容量と計算量の両面で実装上の障壁となる。

この課題に対する提案手法の基本的な着想は、**画像を複数の解像度レベルで処理する**ことである。画像を縮小して処理することで、以下の利点が得られる：

1. **等価的に大きなフィルタ効果**：元画像上で大きな範囲を見る効果を、小さなフィルタで実現できる。
2. **計算量の削減**：低解像度画像では画素数が少ないため、同じフィルタサイズでも計算量が大幅に削減される。
3. **メモリ使用量の削減**：小サイズフィルタを使用するため、必要なラインバッファ数を最小限に抑えられる。

#### 画像縮小と小サイズフィルタの組み合わせ

提案手法の中核となる原理は、画像の**ダウンサンプリング**と**小サイズフィルタ**を組み合わせることである。

画像を1/2に縮小すると、空間的なサンプリング周波数も1/2になる。このとき、縮小画像上で適用する小さなフィルタは、元の解像度の画像においては、より広い範囲に影響を与えることに相当する。例えば：

- **1/2縮小画像上の $3 \times 3$ フィルタ** → 元画像上の **$5 \times 5$ から $7 \times 7$ フィルタに相当**
- **1/4縮小画像上の $3 \times 3$ フィルタ** → 元画像上の **$9 \times 9$ から $13 \times 13$ フィルタに相当**

このように、低解像度レベルで小サイズフィルタを適用することで、元画像に対して大きなフィルタを適用したのと同等の効果を、はるかに少ない計算量とメモリで実現できる。

#### 周波数帯域分解とノイズ除去

多重解像度アプローチのもう一つの利点は、画像を**周波数帯域ごとに分解**できることである。解像度レベルを変えることで、以下のような周波数帯域分解が可能となる：

- **高解像度レベル**：画像の高周波成分（エッジ、細かいディテール）を保持
- **中解像度レベル**：中周波成分（テクスチャ、中程度の構造）を処理
- **低解像度レベル**：低周波成分（大まかな形状、全体的な明るさ分布）を処理

ノイズは主に高周波成分に含まれるが、2.1節で述べたように、画像の重要な情報（エッジなど）も高周波成分に含まれる。**多重解像度分解により、各周波数帯域に対して最適なノイズ除去処理を適用できる**ことが、提案手法の大きな利点である。

#### ハードウェア実装制約への適合性

提案手法は、以下の点でハードウェア実装制約に適合している：

##### 小さなメモリフットプリント

提案手法では、全ての処理段階で $3 \times 3$ または $5 \times 5$ 程度の小サイズフィルタのみを使用する。これにより、必要なラインバッファ数は最大でも3〜5行に抑えられる。フルHD画像の場合でも、約5〜10 KB程度のメモリで実現可能である。

##### ストリーミング処理との整合性

画像の縮小・拡大およびフィルタリング処理は、全て**ラインバッファベースのストリーミング処理**として実装可能である。画像全体をメモリに保持する必要がなく、リアルタイム処理に適している。

##### 計算量の削減

解像度を1/2に縮小すると、画素数は1/4になる。低解像度レベルでの処理により、計算量を大幅に削減できる。例えば、フルHD画像（約207万画素）を1/4に縮小すると約13万画素となり、計算量は約1/16に削減される。

##### パイプライン処理への適合

提案手法の各処理ステップ（縮小、フィルタリング、拡大、統合）は、パイプライン構造として自然に実装できる。各ステージが並行動作することで、高いスループットを実現できる。

### 4.2 アルゴリズムの詳細

提案手法の処理フローは、以下の4つの主要ステップから構成される：

1. **多重解像度分解**：元画像を複数の解像度レベルに縮小
2. **各解像度でのフィルタリング**：各レベルで小サイズフィルタを適用してノイズを低減
3. **高周波成分の抽出**：元画像とフィルタ済み低域成分の差分を取り、各周波数帯域の成分を抽出
4. **統合処理**：各解像度レベルの処理結果を統合して最終出力を生成

以下、各ステップの詳細を述べる。

#### 4.2.1 多重解像度処理

##### 解像度レベルの設定

提案手法では、元画像（レベル0）から始めて、複数の解像度レベルを生成する。一般的には、各レベルで画像サイズを1/2に縮小する**2のべき乗階層**を用いる：

- **レベル0**：元画像 $I_0[m, n]$（解像度 $M \times N$）
- **レベル1**：1/2縮小画像 $I_1[m, n]$（解像度 $M/2 \times N/2$）
- **レベル2**：1/4縮小画像 $I_2[m, n]$（解像度 $M/4 \times N/4$）
- ⋮
- **レベル $L$**：$1/2^L$ 縮小画像 $I_L[m, n]$（解像度 $M/2^L \times N/2^L$）

レベル数 $L$ は、画像サイズとノイズ特性に応じて決定する。一般的には、$L = 2$〜$4$ 程度が適切である。フルHD画像の場合、$L = 3$（1/8縮小まで）とすると、最低解像度は $240 \times 135$ となり、十分な画像構造を保持しつつ計算量を削減できる。

##### ダウンサンプリング手法

画像の縮小には、**アンチエイリアシングフィルタ**を適用した後にサンプリングを行う必要がある。単純な間引き（デシメーション）では、**エイリアシング**（折り返し歪み）が発生し、画質が劣化する。

提案手法では、以下の手順でダウンサンプリングを行う：

1. **ローパスフィルタの適用**：ナイキスト周波数以上の成分を除去
2. **サブサンプリング**：2画素おきにサンプリング

ローパスフィルタとして、計算量とハードウェア実装容易性の観点から、**ガウシアンフィルタの近似**である以下のセパラブルフィルタを用いる：

**水平方向**：

$$
h_x = \frac{1}{4}[1, 2, 1]
$$

**垂直方向**：

$$
h_y = \frac{1}{4}\begin{bmatrix} 1 \\ 2 \\ 1 \end{bmatrix}
$$

2次元フィルタとしては：

$$
h[m, n] = h_x[n] \cdot h_y[m] = \frac{1}{16}\begin{bmatrix}
1 & 2 & 1 \\
2 & 4 & 2 \\
1 & 2 & 1
\end{bmatrix}
$$

このフィルタは、$\sigma \approx 0.85$ のガウシアンフィルタに近い特性を持ち、1/2縮小に適したカットオフ周波数を持つ。重要な点として、係数が2のべき乗の和であるため、**乗算器を使わずにビットシフトと加算のみで実装可能**である：

$$
y = \frac{1}{16}(a + 2b + c) = (a + (b \ll 1) + c) \gg 4
$$

ここで、$\ll$ は左シフト（2倍）、$\gg$ は右シフト（1/16）を表す。

##### レベル間の関係

各解像度レベル $I_k$ は、一つ上のレベル $I_{k-1}$ から生成される：

$$
I_k = \text{Downsample}(I_{k-1}) = \text{Subsample}(h * I_{k-1}, 2)
$$

ここで、$h$ は上述のローパスフィルタ、$*$ は畳み込み演算、$\text{Subsample}(\cdot, 2)$ は2画素おきのサンプリングを示す。

#### 4.2.2 小サイズフィルタによるノイズ低減

##### 各解像度レベルでのフィルタリング

各解像度レベル $k$（$k = 0, 1, \ldots, L$）において、ノイズ低減フィルタを適用する。提案手法では、エッジ保存性と実装容易性を両立するため、**適応的なガウシアンフィルタ**を使用する。

基本的なフィルタリング処理は、2.2節で述べたガウシアンフィルタを用いる：

$$
\tilde{I}_k[m, n] = \sum_{i=-r}^{r} \sum_{j=-r}^{r} g[i, j] \cdot I_k[m+i, n+j]
$$

ここで、$g[i, j]$ はガウシアンフィルタのカーネル、$r$ はフィルタ半径（通常 $r = 1$ または $2$、すなわち $3 \times 3$ または $5 \times 5$ フィルタ）である。

##### フィルタサイズの選択

各解像度レベルで使用するフィルタサイズは、以下の基準で決定する：

- **レベル0（元画像）**：$3 \times 3$ フィルタ。高周波のノイズを軽減しつつ、エッジを保存。
- **レベル1（1/2解像度）**：$3 \times 3$ または $5 \times 5$ フィルタ。中周波のノイズを除去。
- **レベル2以上（1/4以下解像度）**：$5 \times 5$ フィルタ。低周波成分の平滑化。

低解像度レベルでは画素数が少ないため、やや大きなフィルタを使用しても計算量は許容範囲内である。例えば、フルHD画像のレベル2（$480 \times 270$）で $5 \times 5$ フィルタを適用しても、計算量は元画像で $3 \times 3$ フィルタを適用する場合の約1/3である。

##### 標準偏差パラメータの設定

各レベルで使用するガウシアンフィルタの標準偏差 $\sigma_k$ は、以下のように設定する：

$$
\sigma_k = \sigma_0 \cdot 2^{k/2}
$$

ここで、$\sigma_0$ は元画像レベルでの標準偏差（典型的には $\sigma_0 = 0.8$〜$1.2$）である。解像度が1/2になるごとに標準偏差を $\sqrt{2}$ 倍することで、元画像上での等価的なフィルタ範囲を一定に保つ。

ただし、実装上は、各レベルで同一のフィルタカーネル（例：$[1, 2, 1]/4$）を使用し、パラメータ調整を省略することも可能である。

#### 4.2.3 高周波成分の抽出

##### バンドパス成分の計算

多重解像度分解の重要な側面は、各解像度レベル間の**差分**を取ることで、特定の周波数帯域成分を抽出できることである。

レベル $k$ でフィルタリングした結果 $\tilde{I}_k$ をアップサンプリング（後述）して元の解像度に戻した画像を $\tilde{I}_k^{\uparrow}$ とする。このとき、元画像 $I_0$ との差分：

$$
D_k = I_0 - \tilde{I}_k^{\uparrow}
$$

は、$\tilde{I}_k^{\uparrow}$ に含まれない高周波成分、すなわち**バンドパス成分**を表す。

複数の解像度レベルを用いる場合、各レベルの差分は異なる周波数帯域に対応する：

- $D_0 = I_0 - \tilde{I}_0$：最高周波数帯域（ノイズを多く含む）
- $D_1 = \tilde{I}_0 - \tilde{I}_1^{\uparrow}$：高周波帯域
- $D_2 = \tilde{I}_1^{\uparrow} - \tilde{I}_2^{\uparrow}$：中周波帯域
- ⋮

##### 周波数帯域分解の意義

この周波数帯域分解により、以下の利点が得られる：

1. **帯域別ノイズ処理**：各周波数帯域に含まれるノイズの特性に応じて、異なる処理を適用できる。
2. **エッジ保存**：エッジは主に高周波成分に含まれるが、低周波成分との分離により、エッジを保存しつつノイズを除去できる。
3. **適応的な統合**：各帯域の信頼性や品質に応じて、統合時に重み付けを調整できる。

##### 差分成分の処理

抽出した差分成分 $D_k$ には、ノイズとともに画像の重要な高周波情報（エッジなど）も含まれる。提案手法では、この差分成分に対して以下の処理を適用する：

1. **ウェーブレット縮退（Shrinkage）**：小さな振幅成分（ノイズの可能性が高い）を減衰させる。
2. **エッジ検出と保存**：エッジ部分を検出し、その部分は減衰させない（4.3.3節で詳述）。

簡易的な実装では、差分成分にゲイン係数 $\alpha_k$（$0 \leq \alpha_k \leq 1$）を乗じることで、ノイズの影響を低減する：

$$
D_k' = \alpha_k \cdot D_k
$$

$\alpha_k$ は周波数帯域に応じて設定する。高周波帯域（ノイズを多く含む）では $\alpha_k$ を小さく、中低周波帯域では $\alpha_k$ を大きく設定する。

#### 4.2.4 統合処理

##### アップサンプリング手法

低解像度で処理した画像を元の解像度に戻すために、**アップサンプリング**が必要である。アップサンプリングは、ダウンサンプリングの逆操作であり、以下の手順で行う：

1. **ゼロ挿入**：画素間にゼロを挿入して画像サイズを2倍にする。
2. **補間フィルタの適用**：挿入されたゼロ値を周囲の画素値から補間する。

補間フィルタとして、ダウンサンプリングと同じフィルタカーネルを使用する：

$$
h_{\text{up}}[m, n] = 4 \cdot h[m, n] = \frac{1}{4}\begin{bmatrix}
1 & 2 & 1 \\
2 & 4 & 2 \\
1 & 2 & 1
\end{bmatrix}
$$

係数を4倍するのは、ゼロ挿入により信号エネルギーが1/4になることを補正するためである。

##### 多重解像度成分の合成

最終的な出力画像は、各解像度レベルの処理結果を統合して生成する。統合方法として、以下の**ラプラシアンピラミッド再構成**アプローチを用いる：

$$
\text{Output} = \tilde{I}_L^{\uparrow \uparrow \cdots \uparrow} + \sum_{k=0}^{L-1} \alpha_k \cdot D_k^{\uparrow \cdots \uparrow}
$$

ここで、$\tilde{I}_L^{\uparrow \uparrow \cdots \uparrow}$ は最低解像度レベル $L$ の処理結果を元の解像度まで段階的にアップサンプリングしたもの、$D_k^{\uparrow \cdots \uparrow}$ は各レベルの差分成分を元の解像度までアップサンプリングしたものである。

具体的な再構成アルゴリズムは：

```
1. 最低レベル L_L = フィルタリング(I_L)
2. for k = L-1 down to 0:
       L_k_up = アップサンプリング(L_{k+1})
       D_k = フィルタリング(I_k) - L_k_up
       D_k' = α_k × D_k  // ゲイン調整
       L_k = L_k_up + D_k'
3. Output = L_0
```

##### 重み付け係数の設定

各周波数帯域の寄与を制御する重み係数 $\alpha_k$ は、以下の基準で設定する：

- **ノイズレベル依存**：入力画像のノイズが大きい場合、高周波帯域の係数を小さくする（$\alpha_0 \approx 0.3$〜$0.5$）。
- **周波数帯域依存**：一般に、$\alpha_0 < \alpha_1 < \alpha_2 < \cdots$ とし、低周波帯域ほど高い重みを与える。
- **適応的調整**：エッジ強度に応じて局所的に係数を調整することも可能（4.3.3節で詳述）。

典型的な設定例：

$$
\alpha_0 = 0.4, \quad \alpha_1 = 0.7, \quad \alpha_2 = 0.9, \quad \alpha_3 = 1.0
$$

これらの係数は、事前実験により最適化するか、ユーザーが調整可能なパラメータとして提供する。

### 4.3 ハードウェア実装の工夫

提案手法の最大の特徴は、アルゴリズムの設計段階からハードウェア実装を考慮している点である。本節では、FPGAなどのハードウェアへの実装を想定した具体的な工夫について述べる。

#### 4.3.1 横方向処理（FIRフィルタ）

##### ラインバッファを用いた水平方向フィルタリング

画像の水平方向（行方向）のフィルタリングは、**FIR（Finite Impulse Response）フィルタ**として実装できる。1次元FIRフィルタは、入力信号の過去 $N$ サンプルの加重和を計算する：

$$
y[n] = \sum_{k=0}^{N-1} h[k] \cdot x[n-k]
$$

提案手法で使用する $[1, 2, 1]/4$ フィルタは、3タップのFIRフィルタである：

$$
y[n] = \frac{1}{4}(x[n-1] + 2 \cdot x[n] + x[n+1])
$$

実装上は、非因果的なフィルタ（未来のサンプル $x[n+1]$ を使用）を因果的に実現するため、1サンプルの遅延を導入する：

$$
y[n] = \frac{1}{4}(x[n-2] + 2 \cdot x[n-1] + x[n])
$$

##### ハードウェア実装構造

水平方向FIRフィルタのハードウェア実装は、以下の構成要素から成る：

1. **シフトレジスタ**：過去3サンプル $x[n], x[n-1], x[n-2]$ を保持。
2. **乗算器**（または単純化された演算）：各サンプルに係数を乗じる。
3. **加算器**：積を累積加算。
4. **正規化器**：結果を4で除算（2ビット右シフトで実現）。

提案手法では、係数が $[1, 2, 1]$ であるため、乗算器を使わずに以下のように実装できる：

```
// 疑似コード
reg [7:0] x0, x1, x2;  // シフトレジスタ（8ビット画素値）

always @(posedge clk) begin
    x2 <= x1;
    x1 <= x0;
    x0 <= input_pixel;

    // 計算: (x2 + 2*x1 + x0) / 4
    sum = x2 + (x1 << 1) + x0;  // 左シフトで2倍
    output_pixel = sum >> 2;     // 右シフトで1/4
end
```

このように、**乗算器を使わずにシフトと加算のみで実装できる**ため、リソース使用量が最小限となる。

##### セパラブルフィルタの活用

2次元ガウシアンフィルタは分離可能（セパラブル）であるため、2次元畳み込みを2つの1次元畳み込みに分解できる：

$$
h[m, n] = h_y[m] \cdot h_x[n]
$$

これにより、計算量は $O(K^2)$ から $O(2K)$ に削減される。$3 \times 3$ フィルタの場合、画素あたり9回の乗算が、3+3=6回に削減される。

さらに、係数が $[1, 2, 1]$ の場合、前述の通り乗算器が不要となるため、実装コストは大幅に削減される。

##### 必要なラインバッファ数の削減

セパラブルフィルタを用いる場合、処理は以下の2ステップとなる：

1. **水平方向フィルタリング**：各行に対して1次元FIRフィルタを適用。ラインバッファ不要（現在の行のみで処理可能）。
2. **垂直方向フィルタリング**：各列に対してフィルタを適用。$K$ 行のラインバッファが必要。

したがって、$K \times K$ の非セパラブルフィルタでは $K$ 行のラインバッファが必要であるのに対し、セパラブルフィルタでも同じく $K$ 行のラインバッファで済む。しかし、計算量は大幅に削減される。

#### 4.3.2 縦方向処理（IIRフィルタ）

##### IIRフィルタの原理

垂直方向（列方向）のフィルタリングにおいて、さらなるメモリ削減を実現するため、提案手法では**IIR（Infinite Impulse Response）フィルタ**の使用を検討する。

IIRフィルタは、出力のフィードバックを含むフィルタであり、以下の差分方程式で表される：

$$
y[n] = \sum_{k=0}^{M} b_k \cdot x[n-k] + \sum_{k=1}^{N} a_k \cdot y[n-k]
$$

ここで、$b_k$ は順方向（フィードフォワード）係数、$a_k$ は逆方向（フィードバック）係数である。

##### FIRフィルタとの比較

**FIRフィルタ**の特徴：

- 出力は入力の有限個の過去サンプルのみに依存
- 常に安定（係数の設計により不安定になることがない）
- 線形位相特性を容易に実現可能
- 長いインパルス応答を実現するには多くのタップ（メモリ）が必要

**IIRフィルタ**の特徴：

- 出力は過去の入力と過去の出力に依存
- 少ない係数（メモリ）で急峻な周波数特性を実現可能
- 設計によっては不安定になる可能性がある
- 位相特性が非線形となる場合がある

##### IIRフィルタによるメモリ削減効果

垂直方向のフィルタリングにIIRフィルタを用いる最大の利点は、**必要なラインバッファ数を大幅に削減できる**ことである。

例えば、7タップのFIRフィルタは7行のラインバッファを必要とするが、同等の周波数特性を持つ2次IIRフィルタは、わずか2行のラインバッファで実現できる。メモリ使用量は約1/3.5となる。

| フィルタ種類 |   タップ/次数    | ラインバッファ数 | メモリ（フルHD） |
| :----------- | :--------------: | :--------------: | :--------------: |
| 7タップFIR   |        7         |        7         |    約13.4 KB     |
| 2次IIR       | 2（FF）+ 2（FB） |        2         |     約3.8 KB     |
| 削減率       |        -         |     71% 削減     |     71% 削減     |

##### 安定性と因果性の確保

IIRフィルタを画像処理に適用する際の課題は、**安定性**と**因果性**の確保である。

**安定性条件**：
IIRフィルタが安定であるためには、伝達関数の全ての極が単位円内に存在する必要がある。1次IIRフィルタの場合：

$$
y[n] = b_0 x[n] + b_1 x[n-1] + a_1 y[n-1]
$$

安定性条件は：

$$
|a_1| < 1
$$

**因果性**：
画像の垂直方向処理では、ラスタスキャン順（上から下）に処理するため、過去の行（上の行）の出力のみを参照できる。従って、フィードバック項は過去の行の出力を使用する必要がある。

##### 具体的なIIRフィルタ設計

提案手法では、ガウシアン特性に近い周波数応答を持つ1次または2次IIRフィルタを使用する。

**1次IIRローパスフィルタ**：

$$
y[n] = (1-\alpha) x[n] + \alpha y[n-1], \quad 0 < \alpha < 1
$$

このフィルタの伝達関数は：

$$
H(z) = \frac{1-\alpha}{1 - \alpha z^{-1}}
$$

周波数応答（$z = e^{j\omega}$）：

$$
H(\omega) = \frac{1-\alpha}{1 - \alpha e^{-j\omega}}
$$

カットオフ周波数（-3dB点）は、$\alpha$ によって制御される。$\alpha$ が大きいほど、低周波を通過させる特性が強くなる。

典型的な設定：$\alpha = 0.5$〜$0.7$

**2次IIRローパスフィルタ**：

より急峻な周波数特性が必要な場合、2次IIRフィルタを使用する：

$$
y[n] = b_0 x[n] + b_1 x[n-1] + b_2 x[n-2] + a_1 y[n-1] + a_2 y[n-2]
$$

バターワース特性やベッセル特性を持つ係数を設計できる。例えば、正規化カットオフ周波数 $\omega_c = \pi/4$ のバターワース2次フィルタの係数は（双一次変換により）：

$$
b_0 = 0.0674, \quad b_1 = 0.1349, \quad b_2 = 0.0674
$$

$$
a_1 = -1.1430, \quad a_2 = 0.4128
$$

実装上は、係数を固定小数点表現に量子化し、乗算をビットシフトと加算の組み合わせで近似することも可能である。

##### 周波数応答特性

設計したIIRフィルタの周波数応答を、FIRフィルタと比較する：

- **FIR（$[1, 2, 1]/4$）**：緩やかなロールオフ、線形位相
- **1次IIR（$\alpha=0.6$）**：より急峻なロールオフ、非線形位相
- **2次IIR（バターワース）**：さらに急峻なロールオフ

非線形位相は画像処理において問題となる場合があるが、提案手法のように**複数回のフィルタリングと統合処理を組み合わせる**場合、位相歪みは統合処理の段階で緩和される。また、ノイズリダクションという目的においては、位相特性よりも振幅特性の方が重要であり、IIRフィルタの使用は許容される。

#### 4.3.3 方向検出とエッジ保存処理

##### 簡易方向検出フィルタの実装

提案手法の重要な要素の一つは、エッジ部分でのフィルタリング強度を適応的に調整することである。これを実現するため、簡易的な**エッジ検出フィルタ**を実装する。

**水平方向の勾配検出**：

Sobelフィルタの簡易版として、以下の3タップフィルタを使用する：

$$
G_x[m, n] = I[m, n+1] - I[m, n-1]
$$

または、より精度を上げるため：

$$
G_x[m, n] = \frac{1}{2}(I[m-1, n+1] + 2 I[m, n+1] + I[m+1, n+1]) - \frac{1}{2}(I[m-1, n-1] + 2 I[m, n-1] + I[m+1, n-1])
$$

これは、垂直方向に $[1, 2, 1]/4$ でスムージングした後、水平方向に $[-1, 0, 1]$ で微分を取る操作に相当する。

**垂直方向の勾配検出**：

同様に、垂直方向の勾配は：

$$
G_y[m, n] = I[m+1, n] - I[m-1, n]
$$

または：

$$
G_y[m, n] = \frac{1}{2}(I[m+1, n-1] + 2 I[m+1, n] + I[m+1, n+1]) - \frac{1}{2}(I[m-1, n-1] + 2 I[m-1, n] + I[m-1, n+1])
$$

**勾配強度の計算**：

エッジの強度は、勾配ベクトルの大きさとして計算される：

$$
|\nabla I| = \sqrt{G_x^2 + G_y^2}
$$

平方根の計算はハードウェアで高コストであるため、以下の近似を使用する：

$$
|\nabla I| \approx |G_x| + |G_y|
$$

または、より精度の高い近似：

$$
|\nabla I| \approx \max(|G_x|, |G_y|) + \frac{1}{2} \min(|G_x|, |G_y|)
$$

これらの近似は、乗算や平方根を使わずに、絶対値、比較、ビットシフトのみで実装できる。

##### エッジ保存機構

検出した勾配強度に基づいて、フィルタリングの強度を適応的に調整する。基本的なアイデアは、2.2節で述べたイプシロンフィルタと同様である：

- **エッジ部分**（勾配強度が大きい）：フィルタリングを弱める → エッジを保存
- **平坦部分**（勾配強度が小さい）：フィルタリングを強める → ノイズを効果的に除去

適応的な重み係数 $w[m, n]$ は、勾配強度 $g = |\nabla I[m, n]|$ に基づいて計算する：

$$
w[m, n] = \frac{1}{1 + \left(\frac{g}{T}\right)^2}
$$

ここで、$T$ は閾値パラメータであり、どの程度の勾配強度をエッジとみなすかを制御する。

実装上は、複雑な除算や累乗演算を避けるため、以下の簡略化した重み関数を使用する：

$$
w[m, n] = \begin{cases}
1 & \text{if } g < T_1 \\
0.5 & \text{if } T_1 \leq g < T_2 \\
0.2 & \text{if } g \geq T_2
\end{cases}
$$

または、リニアな減衰：

$$
w[m, n] = \max\left(w_{\min}, 1 - \frac{g}{g_{\max}}\right)
$$

ここで、$w_{\min}$ は最小重み（エッジ部分でも完全に0にしない）、$g_{\max}$ は想定される最大勾配強度である。

##### ハードウェア実装上の工夫

エッジ保存機構をハードウェアに実装する際の工夫：

**1. ラインバッファを利用した勾配計算**

勾配計算に必要な近傍画素は、フィルタリングで既に使用しているラインバッファから取得できる。追加のメモリは不要である。

**2. ルックアップテーブル（LUT）による係数調整**

勾配強度から重み係数への変換は、小さなLUT（例：256エントリ）として実装できる。勾配強度（8ビット）をアドレスとして、対応する重み係数（8ビット固定小数点）を読み出す：

```
weight = LUT[gradient_magnitude];
```

**3. ビットシフトと加算による近似演算**

重み係数が $\{1.0, 0.5, 0.25\}$ などの2のべき乗であれば、乗算をビットシフトで実現できる：

```
if (weight == 1.0)
    output = filtered_value;
else if (weight == 0.5)
    output = filtered_value >> 1;  // 1/2
else if (weight == 0.25)
    output = filtered_value >> 2;  // 1/4
```

**4. 元画像との合成**

エッジ保存処理の最終的な出力は、フィルタ済み画像 $\tilde{I}$ と元画像 $I$ の加重平均として計算される：

$$
I_{\text{output}}[m, n] = w[m, n] \cdot \tilde{I}[m, n] + (1 - w[m, n]) \cdot I[m, n]
$$

これにより、エッジ部分では元画像が優先され（$w \approx 0$）、平坦部分ではフィルタ済み画像が優先される（$w \approx 1$）。

##### エッジ保存とノイズ除去のバランス調整

エッジ保存の強度は、閾値パラメータ $T$（または $T_1, T_2$）によって制御される：

- **$T$ が小さい**：小さな勾配もエッジとみなされ、フィルタリングが抑制される。エッジ保存性は高いが、ノイズ除去効果は弱い。
- **$T$ が大きい**：大きな勾配のみエッジとみなされ、広い範囲でフィルタリングが適用される。ノイズ除去効果は高いが、エッジがぼやける可能性がある。

適切な閾値は、画像のコントラストとノイズレベルに依存する。典型的には、ノイズの標準偏差の2〜3倍程度を閾値として設定する。

#### 4.3.4 パイプライン処理

##### 処理フローとパイプライン構造

提案手法の全体処理は、以下のステージから成るパイプライン構造として実装できる：

```
[入力] → [ダウンサンプリング] → [フィルタリング] → [アップサンプリング]
        → [エッジ検出] → [適応合成] → [出力]
```

各ステージは独立して動作し、異なる画素データを同時に処理する。例えば：

- ステージ1：フレーム $t$ の画素 $(m, n)$ をダウンサンプリング
- ステージ2：フレーム $t$ の画素 $(m, n-1)$ をフィルタリング
- ステージ3：フレーム $t$ の画素 $(m, n-2)$ をアップサンプリング
- ⋮

##### ステージ間のデータフロー

各ステージ間には、パイプラインレジスタ（またはFIFOバッファ）が配置され、データを一時保持する。各クロックサイクルで、データがパイプラインを1ステージ進む。

重要な点は、**各ステージの処理時間（レイテンシ）を均等にする**ことである。処理時間が最も長いステージがボトルネックとなり、全体のスループットを制限する。各ステージが1クロックサイクル（または同じ固定サイクル）で処理を完了するように設計することが理想的である。

##### スループット最適化

パイプライン処理により、システムのスループットは大幅に向上する。理想的な場合、各クロックサイクルで1画素（または複数画素）を処理できる。

フルHD（$1920 \times 1080$）を30 fpsで処理する場合、必要なクロック周波数は：

$$
f_{\text{clk}} = 1920 \times 1080 \times 30 \approx 62.2 \text{ MHz}
$$

余裕を持たせて100 MHzのクロックを使用すれば、十分な処理能力が得られる。

さらに高速化が必要な場合、**空間的並列処理**を導入し、1クロックサイクルで複数画素を処理する。例えば、4画素を並列処理すれば、クロック周波数を1/4にできる（または4倍のフレームレートに対応できる）。

##### レイテンシ管理

パイプライン処理では、最初の画素が入力されてから出力されるまでの時間（レイテンシ）が、パイプラインのステージ数に比例して増加する。

提案手法の場合、主要なレイテンシ要因は以下の通り：

1. **ラインバッファによる遅延**：$K$ 行のラインバッファを使用する場合、$K$ ライン分の遅延が発生。
2. **多重解像度処理による遅延**：ダウンサンプリングとアップサンプリングに、それぞれ数ライン分の遅延。
3. **パイプラインステージによる遅延**：各ステージで数クロックサイクルの遅延。

例えば、3レベルの多重解像度処理で、各レベルで3行のラインバッファを使用する場合、合計で10〜15行程度の遅延が発生する。フルHDで30 fpsの場合、これは約0.3〜0.5 ms程度であり、多くのアプリケーションで許容範囲内である。

レイテンシを最小化するためには：

- 必要最小限のラインバッファ数に抑える
- 不要なパイプラインレジスタを削減する
- データ依存性を分析し、処理を可能な限り並列化する

### 4.4 理論的根拠

提案手法の有効性は、信号処理理論と画像処理理論に基づいて説明できる。本節では、周波数領域の観点から、提案手法がノイズリダクションとエッジ保存を両立できる理論的根拠を述べる。

#### 周波数領域での解釈

##### 多重解像度分解と周波数帯域分解の等価性

提案手法の多重解像度分解は、画像を異なる周波数帯域に分解することと等価である。これは、**ウェーブレット変換の離散型**や**ラプラシアンピラミッド**と本質的に同じアプローチである。

画像 $I$ を1/2に縮小する操作は、以下の処理の組み合わせである：

1. ローパスフィルタ $h$ による畳み込み：$I_{\text{low}} = h * I$
2. 2画素おきのサンプリング：$I_{\downarrow} = I_{\text{low}}[2m, 2n]$

周波数領域では、ローパスフィルタにより高周波成分が除去され、サブサンプリングにより周波数軸がスケーリングされる。結果として、縮小画像は元画像の低周波成分のみを保持する。

縮小画像と元画像の差分 $D = I - I_{\text{low}}^{\uparrow}$ は、ローパスフィルタで除去された高周波成分に相当する。これは、**ハイパスフィルタ**を適用した結果と等価である：

$$
D = I - I_{\text{low}}^{\uparrow} \approx (I - h * I^{\uparrow}) = h_{\text{high}} * I
$$

ここで、$h_{\text{high}}$ は $h_{\text{high}} = \delta - h$（$\delta$ はインパルス）で定義されるハイパスフィルタである。

複数の解像度レベルを用いることで、画像は以下のように周波数帯域ごとに分解される：

$$
I = I_{\text{lowest}} + D_L + D_{L-1} + \cdots + D_1 + D_0
$$

ここで、$I_{\text{lowest}}$ は最低周波数成分、$D_k$ は各周波数帯域の成分である。各 $D_k$ は異なる周波数帯域に対応するバンドパス成分となる。

##### サブバンド分解と選択的フィルタリング

この周波数帯域分解により、各帯域に対して**選択的にノイズリダクション処理**を適用できる。これが提案手法の核心である。

- **低周波帯域**（$I_{\text{lowest}}$）：画像の大まかな構造を表現。ノイズの影響が小さいため、そのまま保持または軽微なスムージング。
- **中周波帯域**（$D_2, D_1$）：テクスチャや重要な構造を含む。適度なノイズ低減を適用。
- **高周波帯域**（$D_0$）：エッジのほか、高周波ノイズを多く含む。エッジを保存しつつ、ノイズ成分を減衰。

各帯域に対するゲイン $\alpha_k$ の調整により、周波数選択的なフィルタリングを実現している：

$$
I_{\text{output}} = I_{\text{lowest}} + \alpha_L D_L + \alpha_{L-1} D_{L-1} + \cdots + \alpha_0 D_0
$$

これは、各周波数帯域に異なる振幅特性を持つフィルタを適用することに相当する。

#### フィルタの周波数応答解析

##### 多重解像度フィルタリングの総合周波数特性

提案手法の全体的な周波数応答を解析する。簡単のため、2レベル（元画像 + 1/2縮小画像）の場合を考える。

元画像に直接適用するフィルタを $H_0(\omega)$、1/2縮小画像に適用するフィルタを $H_1(\omega)$ とする。1/2縮小は周波数を2倍にスケーリングするため、元画像の周波数領域での等価フィルタは $H_1(2\omega)$ となる。

提案手法の総合的な周波数応答は：

$$
H_{\text{total}}(\omega) = \alpha_0 H_0(\omega) + \alpha_1 H_1(2\omega)
$$

例えば、$H_0(\omega) = H_1(\omega) = \exp(-\sigma^2 \omega^2 / 2)$（ガウシアンフィルタ）の場合：

$$
H_{\text{total}}(\omega) = \alpha_0 \exp\left(-\frac{\sigma^2 \omega^2}{2}\right) + \alpha_1 \exp\left(-\frac{\sigma^2 (2\omega)^2}{2}\right)
$$

$$
= \alpha_0 \exp\left(-\frac{\sigma^2 \omega^2}{2}\right) + \alpha_1 \exp\left(-2\sigma^2 \omega^2\right)
$$

この特性は、以下の性質を持つ：

- **低周波領域**（$\omega \to 0$）：両項とも1に近いため、$H_{\text{total}} \approx \alpha_0 + \alpha_1$。低周波成分はほぼ保持される。
- **中周波領域**：第2項が急速に減衰し、主に第1項が寄与。$H_{\text{total}} \approx \alpha_0 \exp(-\sigma^2 \omega^2 / 2)$。
- **高周波領域**（$\omega$ が大きい）：両項とも減衰し、$H_{\text{total}} \to 0$。高周波ノイズが除去される。

$\alpha_0$ と $\alpha_1$ を調整することで、**周波数選択性を制御**できる。例えば、$\alpha_0 < \alpha_1$ とすると、中高周波を積極的に減衰させる（ノイズ除去重視）。$\alpha_0 \approx \alpha_1$ とすると、広い帯域で均等にスムージングする。

##### エッジ保存フィルタとの相互作用

さらに、4.3.3節で述べたエッジ適応的な重み付けを考慮すると、エッジ部分では局所的に $\alpha_k$ が小さくなる（または元画像の寄与が大きくなる）。これにより、エッジ近傍では高周波成分がより保存される。

周波数領域での解釈では、この適応的処理は**空間変動フィルタ**（spatial-variant filter）として理解できる。エッジ部分では実効的な周波数帯域幅が広くなり、平坦部では狭くなる。これは、人間の視覚特性とも整合する：エッジやディテールは視覚的に重要であり、保存すべきである。一方、平坦な領域のノイズは視覚的に目立ちやすく、除去すべきである。

#### ノイズ低減効果の理論的説明

##### ガウシアンノイズに対する効果

2.1節で述べたように、ガウシアンノイズは全周波数帯域に均等に分布するホワイトノイズ特性を持つ。元画像を $I$、ノイズを $\eta$ とすると、観測画像は：

$$
I_{\text{observed}} = I + \eta
$$

ローパスフィルタ $H(\omega)$ を適用した後の出力は：

$$
I_{\text{filtered}}(\omega) = H(\omega) \cdot I(\omega) + H(\omega) \cdot \eta(\omega)
$$

ノイズのパワースペクトル密度が $S_{\eta}(\omega) = \sigma_{\eta}^2$（ホワイトノイズ）の場合、出力ノイズのパワースペクトル密度は：

$$
S_{\text{out}}(\omega) = |H(\omega)|^2 \cdot \sigma_{\eta}^2
$$

出力ノイズの分散（ノイズパワー）は：

$$
\sigma_{\text{out}}^2 = \int_{-\infty}^{\infty} |H(\omega)|^2 \cdot \sigma_{\eta}^2 \, d\omega = \sigma_{\eta}^2 \int_{-\infty}^{\infty} |H(\omega)|^2 \, d\omega
$$

ローパスフィルタの場合、$|H(\omega)|^2$ は周波数が高くなるにつれて減少するため、積分値は1未満となり、$\sigma_{\text{out}}^2 < \sigma_{\eta}^2$ が成り立つ。すなわち、**ノイズが低減される**。

ノイズ低減率（NRR: Noise Reduction Ratio）は：

$$
\text{NRR} = \frac{\sigma_{\eta}^2}{\sigma_{\text{out}}^2} = \frac{1}{\int_{-\infty}^{\infty} |H(\omega)|^2 \, d\omega}
$$

提案手法では、複数の解像度レベルで異なる強度のフィルタリングを行うため、総合的なNRRは各帯域のフィルタリング強度に依存する。

##### 信号対雑音比（SNR）の改善

画像品質の定量的な指標として、信号対雑音比（SNR: Signal-to-Noise Ratio）がある：

$$
\text{SNR} = \frac{P_{\text{signal}}}{P_{\text{noise}}} = \frac{\sigma_I^2}{\sigma_{\eta}^2}
$$

ここで、$\sigma_I^2$ は信号（画像）のパワー、$\sigma_{\eta}^2$ はノイズのパワーである。dBスケールでは：

$$
\text{SNR}_{\text{dB}} = 10 \log_{10} \frac{\sigma_I^2}{\sigma_{\eta}^2}
$$

理想的なフィルタは、ノイズを最大限除去しつつ、信号を保持する。しかし、実際のローパスフィルタは、信号の高周波成分も減衰させる。出力のSNRは：

$$
\text{SNR}_{\text{out}} = \frac{\int |H(\omega)|^2 |I(\omega)|^2 d\omega}{\int |H(\omega)|^2 S_{\eta}(\omega) d\omega}
$$

提案手法のエッジ保存機構により、信号の高周波成分（エッジ）が保存されるため、分子の値が大きくなる。一方、ノイズは減衰されるため、分母は小さくなる。結果として、**SNRが改善される**。

#### 空間解像度と周波数帯域の関係

##### サンプリング定理と解像度の影響

ナイキスト-シャノンのサンプリング定理により、サンプリング周波数 $f_s$ で離散化された信号は、$f_s / 2$（ナイキスト周波数）までの周波数成分を正確に表現できる。

画像を1/2に縮小すると、サンプリング周波数が1/2になり、表現可能な最大周波数も1/2になる。これは、元画像の高周波成分が失われることを意味する。

しかし、ノイズリダクションの文脈では、この高周波成分の損失は許容できる場合が多い。なぜなら、**ノイズは主に高周波成分に含まれる**からである。低解像度で処理することにより、ノイズを効果的に除去しつつ、画像の重要な低中周波成分を保持できる。

##### 解像度レベルと周波数帯域の対応

各解像度レベルが担当する周波数帯域は、以下のように対応する：

- **レベル0（元画像）**：$[0, f_s/2]$（全周波数帯域）
- **レベル1（1/2解像度）**：$[0, f_s/4]$（低中周波帯域）
- **レベル2（1/4解像度）**：$[0, f_s/8]$（低周波帯域）
- ⋮

各レベルでフィルタリングを行った後、差分成分を取ることで、以下の周波数帯域が分離される：

- $D_0$：$[f_s/4, f_s/2]$（高周波帯域）
- $D_1$：$[f_s/8, f_s/4]$（中周波帯域）
- $D_2$：$[f_s/16, f_s/8]$（低中周波帯域）
- ⋮

各帯域に対して異なる処理（ゲイン調整、エッジ保存など）を適用することで、周波数選択的なノイズリダクションが実現される。

##### 理論的最適性

ウィーナーフィルタ理論によれば、信号とノイズのパワースペクトルが既知の場合、平均二乗誤差を最小化する最適フィルタは：

$$
H_{\text{Wiener}}(\omega) = \frac{|I(\omega)|^2}{|I(\omega)|^2 + |\eta(\omega)|^2}
$$

提案手法は、厳密にはウィーナーフィルタではないが、多重解像度分解により周波数帯域ごとに異なる処理を適用することで、**ウィーナーフィルタに近い適応的な特性**を実現している。特に、高周波帯域ではノイズが支配的であるため $\alpha_0$ を小さくし、低周波帯域では信号が支配的であるため $\alpha_L$ を大きくすることは、ウィーナーフィルタの精神と合致している。

---

以上、本章では、ハードウェア実装制約を考慮した新しいノイズリダクション手法を提案した。提案手法は、多重解像度アプローチと小サイズフィルタの組み合わせにより、限られたメモリと計算リソースで効果的なノイズ除去を実現する。さらに、IIRフィルタやエッジ保存機構などのハードウェア実装に適した技術を導入することで、リアルタイム処理が可能である。次章では、提案手法の有効性を実験的に検証する。
